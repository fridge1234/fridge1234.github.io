(self.webpackChunkouterspace_webpack=self.webpackChunkouterspace_webpack||[]).push([[560],{4679:(e,n,t)=>{"use strict";t.d(n,{Z:()=>s});var o=t(8081),a=t.n(o),r=t(3645),i=t.n(r)()(a());i.push([e.id,"body{background:#040d21;margin:0;color:#627597}article{background:#fff;width:100%;height:100vh;display:flex;flex-direction:column}article h1{padding:0;margin:auto;color:#000;font-size:4rem;font-family:sans-serif}article #scene1,article #scene2,article #scene3,article #scene4{margin:auto;height:80vh;width:100%;background:#fff}article #scene1 canvas,article #scene2 canvas,article #scene3 canvas,article #scene4 canvas{max-width:100%}",""]);const s=i},5812:e=>{e.exports="uniform float time;\nuniform sampler2D tex;\nuniform float lvl;\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvec3 faceNormal(vec3 pos) {\n\tvec3 fdx = dFdx(pos);\n\tvec3 fdy = dFdy(pos);\n\treturn normalize(cross(fdx, fdy));\n}\nbool isBackSide(vec3 pos) {\n\treturn dot(normalize(pos), faceNormal(pos)) < 0.0;\n}\nvec3 col = vec3(0.7333, 0.6863, 1.0);\nvoid main() {\n\tfloat opacity = 1.0;\n\tif (vPos.z < (lvl + ((cos(((time * 1.0) + vPos.x) + (vPos.y * 2.0)) / 15.0) / 4.0))) {\n\t\topacity = 0.0;\n\t}\n\tgl_FragColor.w = opacity - 0.1;\n\tif (isBackSide(vPos)) {\n\t\tgl_FragColor.xyz = col;\n\t}\n\telse {\n\t\tvec4 t = texture2D(tex, (vUv / 1.5) + fract(time / 15.0));\n\t\tgl_FragColor.xyz = mix(col, col * (1.0 - vNormal.z), distance(0.5, vPos.z));\n\t\tgl_FragColor.xyz *= (normalize(t.xyz).y * (col * 2.0));\n\t}\n}\n"},4596:e=>{e.exports="uniform float time;\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvoid main() {\n\tvec3 transformed = position;\n\tvNormal = normal;\n\tvUv = uv;\n\tvPos = transformed;\n\tvec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n\tgl_Position = projectionMatrix * mvPosition;\n}\n"},1515:e=>{e.exports="uniform float time;\nuniform sampler2D tex;\nuniform vec3 col;\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvec3 faceNormal(vec3 pos) {\n\tvec3 fdx = dFdx(pos);\n\tvec3 fdy = dFdy(pos);\n\treturn normalize(cross(fdx, fdy));\n}\nbool isBackSide(vec3 pos) {\n\treturn dot(normalize(pos), faceNormal(pos)) < 0.0;\n}\nvoid main() {\n\tfloat opacity = 1.0;\n\tif (vPos.z < (0.0 + (sin((time + (vUv.x * 5.0)) + (vUv.y * 3.0)) / 10.0))) {\n\t\topacity = 0.0;\n\t}\n\tgl_FragColor.w = opacity;\n\tif (isBackSide(vPos)) {\n\t\tgl_FragColor.xyz = col;\n\t}\n\telse {\n\t\tvec4 t = texture2D(tex, (vUv / 1.5) + fract(time / 15.0));\n\t\tgl_FragColor.xyz = mix(col, col * (1.0 - vNormal.z), distance(0.5, vPos.z));\n\t\tgl_FragColor.xyz *= (normalize(t.xyz).r * (col * 2.0));\n\t}\n}\n"},4740:e=>{e.exports="uniform float time;\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvoid main() {\n\tvec3 transformed = position;\n\tvNormal = normal;\n\tvUv = uv;\n\tvPos = transformed;\n\tvec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n\tgl_Position = projectionMatrix * mvPosition;\n}\n"},3184:e=>{e.exports="uniform float from;\nuniform float len;\nuniform float time;\nuniform sampler2D tex;\nuniform sampler2D tex2;\nvarying float vIndex;\nvarying vec3 vPos;\nvarying vec2 vUv;\nvec3 rgb(int r, int g, int b) {\n\treturn vec3(float(r) / 255.0, float(g) / 255.0, float(b) / 255.0);\n}\nfloat fresnel(float bias, float scale, float power, vec3 I, vec3 N) {\n\treturn bias + (scale * pow(1.0 + dot(I, N), power));\n}\nvec3 faceNormal(vec3 pos) {\n\tvec3 fdx = dFdx(pos);\n\tvec3 fdy = dFdy(pos);\n\treturn normalize(cross(fdx, fdy));\n}\nbool isBackSide(vec3 pos) {\n\treturn dot(normalize(pos), faceNormal(pos)) < 0.0;\n}\nvoid main() {\n\tvec3 normal = normalize(vPos);\n\tvec3 lig = normalize(normal);\n\tfloat diffuse = max(0.0, dot(lig, normal)) / 1.0;\n\tvec3 I = normalize(vPos - cameraPosition);\n\tfloat R = fresnel(0.05, 0.2, 3.0, I, normal);\n\tvec2 uv = vUv;\n\tuv.x *= 5.0;\n\tuv.x -= (time * 0.01);\n\tuv.y += (-time * 0.0025);\n\tvec3 r = texture2D(tex2, uv).xyz;\n\tr += (r + r);\n\tvec3 col = vec3(((diffuse * rgb(84, 118, 145)) * 1.5) + (r * 0.1));\n\tgl_FragColor.xyz = col;\n\tif ((vIndex > from) && (vIndex < (from + len))) {\n\t\tgl_FragColor.w = 0.5;\n\t}\n\telse {\n\t\tdiscard;\n\t\tgl_FragColor.w = 0.0;\n\t}\n}\n"},8615:e=>{e.exports="attribute float indexattr;\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying float vIndex;\nvoid main() {\n\tvec3 transformed = position;\n\tvIndex = indexattr;\n\tvNormal = normal;\n\tvUv = uv;\n\tvPos = transformed;\n\tvec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n\tgl_Position = projectionMatrix * mvPosition;\n}\n"},5384:e=>{e.exports="uniform float time;\nuniform sampler2D tex;\nvarying vec3 vPos;\nvarying vec2 vUv;\nvec3 rgb(int r, int g, int b) {\n\treturn vec3(float(r) / 255.0, float(g) / 255.0, float(b) / 255.0);\n}\nfloat fresnel(float bias, float scale, float power, vec3 I, vec3 N) {\n\treturn bias + (scale * pow(1.0 + dot(I, N), power));\n}\nvoid main() {\n\tvec3 normal = normalize(vPos);\n\tvec3 lig = normalize(normal);\n\tfloat diffuse = max(0.0, dot(lig, normal)) / 1.0;\n\tvec3 I = normalize(vPos - cameraPosition);\n\tfloat R = fresnel(0.05, 0.2, 3.0, I, normal);\n\tvec2 uv = vUv;\n\tuv.x -= (time * 0.01);\n\tuv.y += (-time * 0.0025);\n\tvec3 r = texture2D(tex, uv).xyz;\n\tr += (r + r);\n\tvec3 col = vec3((((diffuse * rgb(84, 118, 145)) * 1.5) + (r * 0.1)) + (R * 0.5));\n\tgl_FragColor.xyz = col;\n\tgl_FragColor.w = 1.0;\n}\n"},7125:e=>{e.exports="uniform float time;\nuniform sampler2D tex;\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvec3 displacement(vec3 p) {\n\tvec2 u = p.xy * 0.1;\n\tvec2 um = u * 0.1;\n\tum.x += (time * 0.01);\n\tum.y += (-time * 0.0025);\n\tum.x += (um.y * 2.0);\n\tvec3 hlg = texture2D(tex, um).xyz;\n\tvec3 hfn = texture2D(tex, u).xyz * 2.0;\n\tvec3 disp = (hlg * 0.5) + ((hfn * 0.1) * (1.0 - hlg));\n\treturn p + (disp / 1.3);\n}\nvoid main() {\n\tvec3 transformed = displacement(position);\n\ttransformed.y -= 0.3;\n\ttransformed.z -= 0.25;\n\tvNormal = normal;\n\tvUv = uv;\n\tvPos = transformed;\n\tvec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n\tgl_Position = projectionMatrix * mvPosition;\n}\n"},4781:e=>{e.exports="uniform float time;\nuniform sampler2D tex2;\nvarying vec3 vPos;\nvarying vec2 vUv;\nvec3 rgb(int r, int g, int b) {\n\treturn vec3(float(r) / 255.0, float(g) / 255.0, float(b) / 255.0);\n}\nfloat fresnel(float bias, float scale, float power, vec3 I, vec3 N) {\n\treturn bias + (scale * pow(1.0 + dot(I, N), power));\n}\nvoid main() {\n\tvec3 normal = normalize(vPos);\n\tvec3 lig = normalize(normal);\n\tfloat diffuse = max(0.0, dot(lig, normal)) / 1.0;\n\tvec3 I = normalize(vPos - cameraPosition);\n\tfloat R = fresnel(0.05, 0.2, 3.0, I, normal);\n\tvec2 uv = vUv;\n\tuv.x -= (time * 0.01);\n\tuv.y += (-time * 0.0025);\n\tvec3 r = texture2D(tex2, uv).xyz;\n\tr += (r + r);\n\tvec3 col = vec3((((diffuse * rgb(84, 118 - 10, 145)) * 1.5) + (r * 0.1)) + (R * 0.25));\n\tgl_FragColor.xyz = col;\n\tgl_FragColor.w = 1.0;\n}\n"},5141:e=>{e.exports="uniform float time;\nuniform sampler2D tex;\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vTex;\nmat4 rotation3d(vec3 axis, float angle) {\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat4(((oc * axis.x) * axis.x) + c, ((oc * axis.x) * axis.y) - (axis.z * s), ((oc * axis.z) * axis.x) + (axis.y * s), 0.0, ((oc * axis.x) * axis.y) + (axis.z * s), ((oc * axis.y) * axis.y) + c, ((oc * axis.y) * axis.z) - (axis.x * s), 0.0, ((oc * axis.z) * axis.x) - (axis.y * s), ((oc * axis.y) * axis.z) + (axis.x * s), ((oc * axis.z) * axis.z) + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\treturn (rotation3d(axis, angle) * vec4(v, 1.0)).xyz;\n}\nvoid main() {\n\tvec3 transformed = position;\n\tvNormal = normal;\n\tvUv = uv;\n\tvec4 t = texture2D(tex, uv + (time / 1000.0));\n\tvec4 t2 = texture2D(tex, uv - (time / 1000.0));\n\tvec4 t3 = mix(t, t2 * 1.0, 0.5);\n\ttransformed += t3.xyz;\n\tfloat rot = 3.14 * (((time / 5.0) + transformed.x) + transformed.y);\n\ttransformed = rotate(transformed, vec3(0.0, 1.0, 0.0), rot) / 3.0;\n\tfloat scale = 0.8;\n\ttransformed.y -= 0.35;\n\tvPos = transformed;\n\tvec4 mvPosition = modelViewMatrix * vec4(transformed * scale, 1.0);\n\tgl_Position = projectionMatrix * mvPosition;\n}\n"},5735:(e,n,t)=>{"use strict";var o=t(3379),a=t.n(o),r=t(7795),i=t.n(r),s=t(569),l=t.n(s),c=t(3565),v=t.n(c),m=t(9216),d=t.n(m),u=t(4589),p=t.n(u),f=t(4679),x={};x.styleTagTransform=p(),x.setAttributes=v(),x.insert=l().bind(null,"head"),x.domAPI=i(),x.insertStyleElement=d();a()(f.Z,x);f.Z&&f.Z.locals&&f.Z.locals;var g=t(9274),w=t(1051),h=t(7365),y=t(3662),z=t(7411),P=t(8490),b=t(1507),S=t(9365),I=t(2642),U=t(7082);I.ZP.registerPlugin(U.i);class _{constructor(e){this.inviewport=!1,this.onUpdate=()=>{},this.setViewportListener=()=>{U.i.create({start:0,end:"max",onUpdate:this.isInViewPort.bind(this)})},this.setEnviroment=()=>{},this.domElem=e,this.renderer=new g.C({antialias:!0}),this.renderer.setSize(this.domElem.clientWidth,this.domElem.clientHeight),this.domElem.appendChild(this.renderer.domElement),this.camera=new w.c(75,1,.1,1e5),this.scene=new h.x,this.scene.background=new y.I("#ffffff"),this.pmremGenerator=new z.a(this.renderer),this.pmremGenerator.compileEquirectangularShader(),this.controls=new S.z(this.camera,this.renderer.domElement),this.isInViewPort(),this.setViewportListener(),this.sceneSetup(),this.onWindowResize(),window.addEventListener("resize",this.onWindowResize.bind(this),!1)}isInViewPort(){const e=U.i.isInViewport(this.domElem);this.inviewport!==e&&(this.inviewport=e,this.inviewport&&this.render())}onWindowResize(){this.camera.aspect=this.domElem.clientWidth/this.domElem.clientHeight,this.camera.updateProjectionMatrix(),this.renderer.setSize(this.domElem.clientWidth,this.domElem.clientHeight)}sceneSetup(){const e=new P.c(new y.I("white"),15,100),n=new b.M("white");e.position.set(50,50,50),this.camera.lookAt(0,0,0),this.scene.add(e,n,this.camera),this.setEnviroment()}render(){this.onUpdate(),this.renderer.render(this.scene,this.camera),this.inviewport&&requestAnimationFrame((()=>this.render()))}animate(e){this.onUpdate=e,this.render()}}var N=t(2980),D=t(1661),F=t(1621),k=t(6454),E=t(2785),C=t(8045),j=t(2010),M=t(4740),A=t.n(M),Z=t(1515),T=t.n(Z);const R=(new N.d).load("/assets/low_noise.png");R.wrapT=R.wrapS=D.rpg;const V=(new N.d).load("/assets/wat1.jpg");V.wrapT=V.wrapS=D.rpg;const K=new y.I("#fed9c6"),W=new y.I("#cdc0d4"),q=e=>{const n=new F.j({vertexShader:A(),fragmentShader:T(),side:D.ehD,uniforms:{time:{value:0},tex:{value:R},tex2:{value:V},col:{value:e}},transparent:!0}),t=new k.K(new E.x(1,32,32),n);return t.rotation.x=Math.PI/2,t},B=()=>{const e=new k.K(new E.x(1,32,32),new C.E({color:"white",opacity:.1,metalness:.9,roughness:.05,envMapIntensity:.9,reflectivity:.2,refractionRatio:.985,ior:.9,side:D.ehD,transparent:!0}));return e.scale.multiplyScalar(1.01),e},$=q(K),H=B(),L=q(W),G=B();$.position.x+=1.25,H.position.x+=1.25,L.position.x-=1.25,G.position.x-=1.25;const O=new j.Z;O.add($,H,L,G);const Y={group:O,update:()=>{$.material.uniforms.time.value+=.05,L.material.uniforms.time.value+=.05}};var J=t(4596),Q=t.n(J),X=t(5812),ee=t.n(X);const ne=(new N.d).load("/assets/low_noise.png");ne.wrapT=ne.wrapS=D.rpg;(new N.d).load("/assets/1.png").mapping=D.dSO;const te=e=>{const n=new F.j({vertexShader:Q(),fragmentShader:ee(),side:D.ehD,uniforms:{time:{value:0},tex:{value:ne},lvl:{value:e}},transparent:!0}),t=new k.K(new E.x(1,32,32),n);return t.rotation.x=Math.PI/2,t},oe=()=>{const e=new k.K(new E.x(1,32,32),new C.E({color:"white",emissive:"silver",metalness:1,roughness:.2,opacity:.25,clearcoat:1,clearcoatRoughness:1,side:D.ehD,transparent:!0}));return e.scale.multiplyScalar(1.01),e.material.needsUpdate=!0,e},ae=te(.75),re=oe();ae.position.x+=3,re.position.x+=3;const ie=te(-.5),se=oe();ie.position.x-=3,se.position.x-=3;const le=te(0),ce=oe(),ve=new j.Z;ve.add(ae,re,ie,se,le,ce);const me={group:ve,update:()=>{ae.material.uniforms.time.value+=.05,ie.material.uniforms.time.value+=.05,le.material.uniforms.time.value+=.05}};var de=t(6881),ue=t(7546),pe=t(3868),fe=t(140),xe=t(8615),ge=t.n(xe),we=t(3184),he=t.n(we),ye=t(7125),ze=t.n(ye),Pe=t(5384),be=t.n(Pe);const Se=new j.Z,Ie=(new N.d).load("/assets/wat1.jpg");Ie.wrapT=Ie.wrapS=D.rpg;const Ue=()=>{const e=new F.j({vertexShader:(n=ze(),`${n}`.replace(/#include < (.+) >/g,"#include <$1>")),fragmentShader:be(),side:D.ehD,uniforms:{time:{value:0},tex:{value:Ie}},transparent:!0});var n;e.needsUpdate=!0;const t=new E.x(1,132,132);return new k.K(t,e)},_e=Ue();Se.add(_e);const Ne={group:Se,update:()=>{_e.material.uniforms.time.value+=.025}},De=new j.Z,Fe=(new N.d).load("/assets/low_noise.png");Fe.wrapT=Fe.wrapS=D.rpg;const ke=(new N.d).load("/assets/wat1.jpg");ke.wrapT=ke.wrapS=D.rpg;const Ee=[[0,-1,0],[0,0,0],[0,0,4],[4,0,4],[4,0,-2],[0,0,-2],[0,2,-2],[0,2,4],[4,2,4],[4,2,-2],[2,2,-2],[2,2,1],[2,-2,1],[2,-2,8],[2,4,8],[0,4,8],[0,5,8]].map((e=>new de.P(...e)));var Ce=new ue.Y(Ee);const je=new pe.W(Ce,220,.5,8),Me=new k.K(je,new C.E({color:"white",roughness:.5,metalness:1,clearcoat:1,clearcoatRoughness:1,side:D.ehD,transparent:!0,opacity:.15})),Ae=new pe.W(Ce,220,.5,8),Ze=Ae.attributes.position.array.length,Te=[...Array(Ze/3)].map(((e,n)=>n)),Re=new Float32Array(Te);Ae.setAttribute("indexattr",new fe.Tl(Re,1));const Ve=new k.K(Ae,new F.j({vertexShader:ge(),fragmentShader:he(),side:D.ehD,uniforms:{time:{value:0},tex:{value:Fe},tex2:{value:ke},from:{value:0},len:{value:200}}})),Ke=Ue();Ke.position.set(0,6,7.5);const We=Ue();We.position.set(0,-3,-.5),De.add(Ve,Me,Ke,We);const qe={group:De,update:()=>{Ve.material.uniforms.from.value>Ze/3+200&&(Ve.material.uniforms.from.value=0),Ve.material.uniforms.from.value+=8,Ve.material.uniforms.time.value+=.05,Ke.material.uniforms.time.value+=.05,We.material.uniforms.time.value+=.05}};var Be=t(1043),$e=t(5141),He=t.n($e),Le=t(4781),Ge=t.n(Le);const Oe=new j.Z,Ye=(new N.d).load("/assets/wat1.jpg");Ye.wrapT=Ye.wrapS=D.rpg;const Je=(new N.d).load("/assets/wat2.png");Je.wrapT=Je.wrapS=D.rpg;const Qe=new Be.F(3,.3,1e3,16,2,2),Xe=(()=>{const e=new F.j({vertexShader:(n=He(),`${n}`.replace(/#include < (.+) >/g,"#include <$1>")),fragmentShader:Ge(),side:D.ehD,uniforms:{time:{value:0},tex:{value:Je},tex2:{value:Ye}},transparent:!0});var n;e.needsUpdate=!0;return new k.K(Qe,e)})();Oe.add(Xe);const en={group:Oe,update:()=>{Xe.material.uniforms.time.value+=.05}};const nn=new(t(7096).E),tn=new _(document.querySelector("#scene1"));tn.camera.position.set(0,0,-3),tn.camera.lookAt(0,0,0),tn.scene.add(Ne.group),tn.scene.add(en.group);let on=[...Array(4)];const an=new j.Z;nn.loadAsync("/assets/low_poly_bitcoin.gltf").then((e=>{const n=e.scenes[0];n.scale.multiplyScalar(.002);new de.P(0,1,0);on=on.map((e=>{const t=n.clone(!0);an.add(t);return I.ZP.ticker.add((()=>{t.rotation.y+=.04})),t})),an.children[0].position.set(-1.1,-1.1,1),an.children[1].position.set(-1.1,1.1,1.1),an.children[2].position.set(1.35,.2,1.35),an.children[3].position.set(-1,-.2,-1.35),an.children.forEach((e=>e.position.multiplyScalar(.85))),tn.scene.add(an)})),tn.animate((()=>{en.update(),Ne.update(),an.rotation.y+=.01}));const rn=new _(document.querySelector("#scene2"));rn.camera.position.set(8,6,-3),rn.camera.lookAt(0,2,0),rn.scene.add(qe.group),rn.animate((()=>{qe.update()}));const sn=new _(document.querySelector("#scene3"));sn.camera.position.set(0,1,-4),sn.camera.lookAt(Y.group.position),sn.scene.add(Y.group),sn.animate((()=>{Y.update()}));const ln=new _(document.querySelector("#scene4"));ln.camera.position.set(0,1,-4),ln.camera.lookAt(me.group.position),ln.scene.add(me.group),ln.animate((()=>{me.update()}))}}]);