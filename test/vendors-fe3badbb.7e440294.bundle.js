"use strict";(self.webpackChunkouterspace_webpack=self.webpackChunkouterspace_webpack||[]).push([[874],{7858:(e,t,r)=>{r.d(t,{N:()=>s});var n=r(6469);class s extends n.T{constructor(){super(),this.type="Bone"}}s.prototype.isBone=!0},2010:(e,t,r)=>{r.d(t,{Z:()=>s});var n=r(6469);class s extends n.T{constructor(){super(),this.type="Group"}}s.prototype.isGroup=!0},1301:(e,t,r)=>{r.d(t,{x:()=>y});var n=r(4699),s=r(7540),o=r(9203),i=r(6469),a=r(6881),c=r(5785),u=r(9046),h=r(140);const l=new a.P,p=new a.P,f=new o.y,d=new s.z,m=new n.a;class y extends i.T{constructor(e=new u.u,t=new c.n){super(),this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position,r=[0];for(let e=1,n=t.count;e<n;e++)l.fromBufferAttribute(t,e-1),p.fromBufferAttribute(t,e),r[e]=r[e-1],r[e]+=l.distanceTo(p);e.setAttribute("lineDistance",new h.a$(r,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(e,t){const r=this.geometry,n=this.matrixWorld,s=e.params.Line.threshold,o=r.drawRange;if(null===r.boundingSphere&&r.computeBoundingSphere(),m.copy(r.boundingSphere),m.applyMatrix4(n),m.radius+=s,!1===e.ray.intersectsSphere(m))return;f.copy(n).invert(),d.copy(e.ray).applyMatrix4(f);const i=s/((this.scale.x+this.scale.y+this.scale.z)/3),c=i*i,u=new a.P,h=new a.P,l=new a.P,p=new a.P,y=this.isLineSegments?2:1;if(r.isBufferGeometry){const n=r.index,s=r.attributes.position;if(null!==n){for(let r=Math.max(0,o.start),i=Math.min(n.count,o.start+o.count)-1;r<i;r+=y){const o=n.getX(r),i=n.getX(r+1);u.fromBufferAttribute(s,o),h.fromBufferAttribute(s,i);if(d.distanceSqToSegment(u,h,p,l)>c)continue;p.applyMatrix4(this.matrixWorld);const a=e.ray.origin.distanceTo(p);a<e.near||a>e.far||t.push({distance:a,point:l.clone().applyMatrix4(this.matrixWorld),index:r,face:null,faceIndex:null,object:this})}}else{for(let r=Math.max(0,o.start),n=Math.min(s.count,o.start+o.count)-1;r<n;r+=y){u.fromBufferAttribute(s,r),h.fromBufferAttribute(s,r+1);if(d.distanceSqToSegment(u,h,p,l)>c)continue;p.applyMatrix4(this.matrixWorld);const n=e.ray.origin.distanceTo(p);n<e.near||n>e.far||t.push({distance:n,point:l.clone().applyMatrix4(this.matrixWorld),index:r,face:null,faceIndex:null,object:this})}}}else r.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,r=Object.keys(t);if(r.length>0){const e=t[r[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,r=e.length;t<r;t++){const r=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[r]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}y.prototype.isLine=!0},2232:(e,t,r)=>{r.d(t,{b:()=>s});var n=r(1301);class s extends n.x{constructor(e,t){super(e,t),this.type="LineLoop"}}s.prototype.isLineLoop=!0},5920:(e,t,r)=>{r.d(t,{e:()=>c});var n=r(1301),s=r(6881),o=r(140);const i=new s.P,a=new s.P;class c extends n.x{constructor(e,t){super(e,t),this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position,r=[];for(let e=0,n=t.count;e<n;e+=2)i.fromBufferAttribute(t,e),a.fromBufferAttribute(t,e+1),r[e]=0===e?0:r[e-1],r[e+1]=r[e]+i.distanceTo(a);e.setAttribute("lineDistance",new o.a$(r,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}c.prototype.isLineSegments=!0},6454:(e,t,r)=>{r.d(t,{K:()=>G});var n=r(6881),s=r(1138),o=r(4699),i=r(7540),a=r(9203),c=r(6469),u=r(8121),h=r(1661),l=r(6173),p=r(9046);const f=new a.y,d=new i.z,m=new o.a,y=new n.P,b=new n.P,g=new n.P,x=new n.P,T=new n.P,M=new n.P,w=new n.P,v=new n.P,E=new n.P,B=new s.F,I=new s.F,S=new s.F,A=new n.P,R=new n.P;class G extends c.T{constructor(e=new p.u,t=new l.v){super(),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,r=Object.keys(t);if(r.length>0){const e=t[r[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,r=e.length;t<r;t++){const r=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[r]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const r=this.geometry,n=this.material,s=this.matrixWorld;if(void 0===n)return;if(null===r.boundingSphere&&r.computeBoundingSphere(),m.copy(r.boundingSphere),m.applyMatrix4(s),!1===e.ray.intersectsSphere(m))return;if(f.copy(s).invert(),d.copy(e.ray).applyMatrix4(f),null!==r.boundingBox&&!1===d.intersectsBox(r.boundingBox))return;let o;if(r.isBufferGeometry){const s=r.index,i=r.attributes.position,a=r.morphAttributes.position,c=r.morphTargetsRelative,u=r.attributes.uv,h=r.attributes.uv2,l=r.groups,p=r.drawRange;if(null!==s)if(Array.isArray(n))for(let r=0,f=l.length;r<f;r++){const f=l[r],m=n[f.materialIndex];for(let r=Math.max(f.start,p.start),n=Math.min(s.count,Math.min(f.start+f.count,p.start+p.count));r<n;r+=3){const n=s.getX(r),l=s.getX(r+1),p=s.getX(r+2);o=P(this,m,e,d,i,a,c,u,h,n,l,p),o&&(o.faceIndex=Math.floor(r/3),o.face.materialIndex=f.materialIndex,t.push(o))}}else{for(let r=Math.max(0,p.start),l=Math.min(s.count,p.start+p.count);r<l;r+=3){const l=s.getX(r),p=s.getX(r+1),f=s.getX(r+2);o=P(this,n,e,d,i,a,c,u,h,l,p,f),o&&(o.faceIndex=Math.floor(r/3),t.push(o))}}else if(void 0!==i)if(Array.isArray(n))for(let r=0,s=l.length;r<s;r++){const s=l[r],f=n[s.materialIndex];for(let r=Math.max(s.start,p.start),n=Math.min(i.count,Math.min(s.start+s.count,p.start+p.count));r<n;r+=3){o=P(this,f,e,d,i,a,c,u,h,r,r+1,r+2),o&&(o.faceIndex=Math.floor(r/3),o.face.materialIndex=s.materialIndex,t.push(o))}}else{for(let r=Math.max(0,p.start),s=Math.min(i.count,p.start+p.count);r<s;r+=3){o=P(this,n,e,d,i,a,c,u,h,r,r+1,r+2),o&&(o.faceIndex=Math.floor(r/3),t.push(o))}}}else r.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}function P(e,t,r,o,i,a,c,l,p,f,d,m){y.fromBufferAttribute(i,f),b.fromBufferAttribute(i,d),g.fromBufferAttribute(i,m);const G=e.morphTargetInfluences;if(a&&G){w.set(0,0,0),v.set(0,0,0),E.set(0,0,0);for(let e=0,t=a.length;e<t;e++){const t=G[e],r=a[e];0!==t&&(x.fromBufferAttribute(r,f),T.fromBufferAttribute(r,d),M.fromBufferAttribute(r,m),c?(w.addScaledVector(x,t),v.addScaledVector(T,t),E.addScaledVector(M,t)):(w.addScaledVector(x.sub(y),t),v.addScaledVector(T.sub(b),t),E.addScaledVector(M.sub(g),t)))}y.add(w),b.add(v),g.add(E)}e.isSkinnedMesh&&(e.boneTransform(f,y),e.boneTransform(d,b),e.boneTransform(m,g));const P=function(e,t,r,n,s,o,i,a){let c;if(c=t.side===h._Li?n.intersectTriangle(i,o,s,!0,a):n.intersectTriangle(s,o,i,t.side!==h.ehD,a),null===c)return null;R.copy(a),R.applyMatrix4(e.matrixWorld);const u=r.ray.origin.distanceTo(R);return u<r.near||u>r.far?null:{distance:u,point:R.clone(),object:e}}(e,t,r,o,y,b,g,A);if(P){l&&(B.fromBufferAttribute(l,f),I.fromBufferAttribute(l,d),S.fromBufferAttribute(l,m),P.uv=u.C.getUV(A,y,b,g,B,I,S,new s.F)),p&&(B.fromBufferAttribute(p,f),I.fromBufferAttribute(p,d),S.fromBufferAttribute(p,m),P.uv2=u.C.getUV(A,y,b,g,B,I,S,new s.F));const e={a:f,b:d,c:m,normal:new n.P,materialIndex:0};u.C.getNormal(y,b,g,e.normal),P.face=e}return P}G.prototype.isMesh=!0},2306:(e,t,r)=>{r.d(t,{w:()=>d});var n=r(4699),s=r(7540),o=r(9203),i=r(6469),a=r(6881),c=r(6679),u=r(9046);const h=new o.y,l=new s.z,p=new n.a,f=new a.P;class d extends i.T{constructor(e=new u.u,t=new c.U){super(),this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const r=this.geometry,n=this.matrixWorld,s=e.params.Points.threshold,o=r.drawRange;if(null===r.boundingSphere&&r.computeBoundingSphere(),p.copy(r.boundingSphere),p.applyMatrix4(n),p.radius+=s,!1===e.ray.intersectsSphere(p))return;h.copy(n).invert(),l.copy(e.ray).applyMatrix4(h);const i=s/((this.scale.x+this.scale.y+this.scale.z)/3),a=i*i;if(r.isBufferGeometry){const s=r.index,i=r.attributes.position;if(null!==s){for(let r=Math.max(0,o.start),c=Math.min(s.count,o.start+o.count);r<c;r++){const o=s.getX(r);f.fromBufferAttribute(i,o),m(f,o,a,n,e,t,this)}}else{for(let r=Math.max(0,o.start),s=Math.min(i.count,o.start+o.count);r<s;r++)f.fromBufferAttribute(i,r),m(f,r,a,n,e,t,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,r=Object.keys(t);if(r.length>0){const e=t[r[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,r=e.length;t<r;t++){const r=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[r]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function m(e,t,r,n,s,o,i){const c=l.distanceSqToPoint(e);if(c<r){const r=new a.P;l.closestPointToPoint(e,r),r.applyMatrix4(n);const u=s.ray.origin.distanceTo(r);if(u<s.near||u>s.far)return;o.push({distance:u,distanceToRay:Math.sqrt(c),point:r,index:t,face:null,object:i})}}d.prototype.isPoints=!0},2170:(e,t,r)=>{r.d(t,{O:()=>h});var n=r(1661),s=r(7858),o=r(9203),i=r(3993),a=r(2043);const c=new o.y,u=new o.y;class h{constructor(e=[],t=[]){this.uuid=a.DO(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(16*e.length),0===t.length)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let e=0,t=this.bones.length;e<t;e++)this.boneInverses.push(new o.y)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const t=new o.y;this.bones[e]&&t.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(t)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&t.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&(t.parent&&t.parent.isBone?(t.matrix.copy(t.parent.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}}update(){const e=this.bones,t=this.boneInverses,r=this.boneMatrices,n=this.boneTexture;for(let n=0,s=e.length;n<s;n++){const s=e[n]?e[n].matrixWorld:u;c.multiplyMatrices(s,t[n]),c.toArray(r,16*n)}null!==n&&(n.needsUpdate=!0)}clone(){return new h(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(4*this.bones.length);e=a.h3(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const r=new i.I(t,e,e,n.wk1,n.VzW);return this.boneMatrices=t,this.boneTexture=r,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,r=this.bones.length;t<r;t++){const r=this.bones[t];if(r.name===e)return r}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let r=0,n=e.bones.length;r<n;r++){const n=e.bones[r];let i=t[n];void 0===i&&(console.warn("THREE.Skeleton: No bone found with UUID:",n),i=new s.N),this.bones.push(i),this.boneInverses.push((new o.y).fromArray(e.boneInverses[r]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,r=this.boneInverses;for(let n=0,s=t.length;n<s;n++){const s=t[n];e.bones.push(s.uuid);const o=r[n];e.boneInverses.push(o.toArray())}return e}}},2127:(e,t,r)=>{r.d(t,{T:()=>p});var n=r(6454),s=r(9203),o=r(6881),i=r(223);const a=new o.P,c=new i.L,u=new i.L,h=new o.P,l=new s.y;class p extends n.K{constructor(e,t){super(e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new s.y,this.bindMatrixInverse=new s.y}copy(e){return super.copy(e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,void 0===t&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new i.L,t=this.geometry.attributes.skinWeight;for(let r=0,n=t.count;r<n;r++){e.x=t.getX(r),e.y=t.getY(r),e.z=t.getZ(r),e.w=t.getW(r);const n=1/e.manhattanLength();n!==1/0?e.multiplyScalar(n):e.set(1,0,0,0),t.setXYZW(r,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const r=this.skeleton,n=this.geometry;c.fromBufferAttribute(n.attributes.skinIndex,e),u.fromBufferAttribute(n.attributes.skinWeight,e),a.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let e=0;e<4;e++){const n=u.getComponent(e);if(0!==n){const s=c.getComponent(e);l.multiplyMatrices(r.bones[s].matrixWorld,r.boneInverses[s]),t.addScaledVector(h.copy(a).applyMatrix4(l),n)}}return t.applyMatrix4(this.bindMatrixInverse)}}p.prototype.isSkinnedMesh=!0}}]);